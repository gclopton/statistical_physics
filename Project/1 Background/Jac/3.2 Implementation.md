

# Phase 0 Project Repository Setup


``` title:"Phase 0 Directory Structure"
ec-reaxff-robustness/
├─ README.md
├─ LICENSE
├─ .gitignore
├─ Makefile
├─ CITATION.cff
├─ docs/
│  ├─ design_overview.md
│  └─ figures/               # (empty; diagrams about workflow/builds)
├─ env/
│  ├─ lammps_build_notes.md  # commit hash, cmake options, MPI/OMP layout
│  ├─ conda-environment.yml  # Python 3.11 + pinned deps
│  ├─ requirements.lock.txt  # exact versions (pip-compile or uv lock)
│  └─ .python-version        # 3.11.x (for pyenv)
├─ sim/
│  ├─ seedlist.txt           # 1..200 (one per line)
│  ├─ configs/
│  │  ├─ run_constants.in    # timestep, neighbor, thermostat, I/O cadences
│  │  ├─ A_QEq.in            # include: paramfile A + charge style/tolerances
│  │  ├─ A_ACKS2.in
│  │  ├─ B_QEq.in
│  │  ├─ B_ACKS2.in
│  │  ├─ params/
│  │  │  ├─ reaxff_A.ff      # parameter set A (placeholder)
│  │  │  └─ reaxff_B.ff      # parameter set B (placeholder)
│  │  └─ README.md           # what’s invariant vs. variant; parity notes
│  ├─ prep/
│  │  ├─ pack_ec_lipf6.py    # generate initial packed box at target composition
│  │  ├─ equilibrate_npt_nvt.in   # LAMMPS script used once to equilibrate
│  │  ├─ common_start/       # produced in Phase 1 (empty in Phase 0)
│  │  │  ├─ (placeholder)
│  │  └─ README.md           # state variables (T, ρ, x); box-size rationale
│  └─ prod/
│     ├─ templates/
│     │  ├─ settle_then_prod.in   # generic, pulls in run_constants + variant
│     │  └─ input_vars.template   # jinja/format template for per-replica inputs
│     ├─ slurm/
│     │  ├─ launch_array.sh       # one array per variant; maps TASK_ID→seed
│     │  └─ cluster_profile.md    # partition, nodes, recommended resources
│     └─ README.md
├─ analysis/
│  ├─ detectors/
│  │  ├─ event_rules.yaml     # BO thresholds, hysteresis, tie-break rules
│  │  └─ detect_events.py     # parses BO/charges to first-event labels/times
│  ├─ structure/
│  │  ├─ rdf_coord.py         # g(r) + running coordination (pre-event only)
│  │  └─ lif_contact.py       # Li–F contact frequency/lifetime metrics
│  ├─ survival/
│  │  ├─ km_curves.py         # KM, RMST, logrank
│  │  └─ bootstrap_utils.py   # replica-level bootstrap, paired resampling
│  ├─ viz/
│  │  ├─ dashboard.py         # one-screen panels generator
│  │  └─ styles.mplstyle
│  ├─ io/
│  │  ├─ load_trajectories.py # MDAnalysis readers; minimal columns
│  │  └─ manifests.py         # run manifest schema + validation
│  └─ README.md
└─ results/
   ├─ figures/                # auto-generated (empty in Phase 0)
   ├─ tables/                 # CSV summaries (empty in Phase 0)
   └─ logs/                   # run + analysis manifests (empty in Phase 0)

```


```.gitignore title:.gitignore
# .gitignore
__pycache__/
*.pyc
.env
.venv/
.mamba/
.envrc
.DS_Store
results/**/*
!results/.keep
sim/prep/packed/*
sim/prep/equil/*
sim/prep/nve_check/*
sim/prep/common_start/*
sim/prod/**/r*/   # runtime outputs
.envrc
.ipynb_checkpoints/
```


```make title:"Makefile"
# Makefile
.PHONY: env seeds dirs

PY?=python

dirs:
	mkdir -p sim/configs/params sim/prep/{packed,equil,nve_check,common_start} sim/prod/{templates,generators,slurm} \
	         analysis/{io,viz} results/{figures,tables,logs,prep_logs}

env:
	conda env create -f env/conda-environment.yml || mamba env create -f env/conda-environment.yml
	@echo "Activate with: conda activate ec-reaxff"

seeds:
	@seq 1 200 > sim/seedlist.txt
	@echo "Wrote 200 seeds to sim/seedlist.txt"

```



```yaml title:"env/conda-environment.yml"
# env/conda-environment.yml
name: ec-reaxff
channels: [conda-forge, defaults]
dependencies:
  - python=3.11
  - pip
  - numpy
  - pandas
  - scipy
  - matplotlib
  - mdanalysis
  - networkx
  - pip:
      - lifelines==0.28.0
```



```text title:"env/requirements.lock.txt"
# env/requirements.lock.txt
# Optional: if you prefer pip locking (pip-tools/uv), pin exact wheels here.
# numpy==...
# pandas==...
# lifelines==0.28.0
```


```text title:"env/.python-version"
# env/.python-version
3.11.9
```


```markdown title:"<!-- env/lammps_build_notes.md -->"
<!-- env/lammps_build_notes.md -->
# LAMMPS Build Notes (ReaxFF + ACKS2)

- Commit: TODO
- Source URL: TODO
- CMake options:
  - -D BUILD_LIB=on
  - -D LAMMPS_EXCEPTIONS=on
  - -D PKG_REAXFF=yes
  - -D PKG_KSPACE=yes
  - -D PKG_MOLECULE=yes
  - -D PKG_EXTRA-FIX=yes
- Compiler / MPI:
  - CXX: TODO (e.g., icpx 2025.0 / mpicxx)
  - OpenMP: on/off
- Parallel layout used in this project:
  - MPI ranks per run: TODO
  - OMP threads per rank: TODO
- Notes:
  - QEq/ACKS2 tolerances matched; see sim/configs/*_QEq.in and *_ACKS2.in later.
```



```text title:sim/seedlist.txt
# sim/seedlist.txt (generated by `make seeds`; example head)
1
2
3
4
5
...
200

```


```ini title:"sim/configs/run_constants.in"
# sim/configs/run_constants.in
# Invariant mechanics for all variants. Filled in during Phase 2, but stub here.
# Include with: include sim/configs/run_constants.in

variable T equal 330.0                 # [K] target temperature (placeholder)
variable dt equal 0.10e-15             # [s] 0.10 fs (placeholder; validate in Phase 2)
variable neigh_skin equal 2.0          # [Å] neighbor skin (placeholder)
variable neigh_every equal 1           # rebuild frequency
variable thermo_every equal 100        # print stride
variable dump_coord_stride equal 1000  # ~100–200 fs once dt validated
variable dump_bo_stride equal 100      # 10–20 fs once dt validated

# Neighbor & integration
neighbor ${neigh_skin} bin
neigh_modify every ${neigh_every} delay 0 check yes
timestep ${dt}
fix int all nve                          # replaced by thermostat in production scripts

# Thermostat choice lives here to keep parity; pick one and stick with it
# Example: Langevin (placeholder parameters; finalize in Phase 2)
# fix tstat all langevin ${T} ${T} 50.0 12345 zero yes
# fix_modify tstat temp thermo_temp

# Output minimal thermo; bond-order & charges are defined in log_custom.compute later
thermo ${thermo_every}
thermo_style custom step temp pe ke etotal press

```



```markdown title:"<!-- sim/configs/README.md -->"
<!-- sim/configs/README.md -->
# Configs

- `run_constants.in`: single source of truth for timestep, neighbor/thermostat, and I/O cadences.
- `params/`: drop `reaxff_A.ff` and `reaxff_B.ff` here (Phase 3).
- Variant includes (`A_QEq.in`, `A_ACKS2.in`, `B_QEq.in`, `B_ACKS2.in`) live here in Phase 3 and should only:
  - point to a param file, and
  - set the charge-equilibration style/tolerances.
Everything else must come from `run_constants.in`.

```



```Python title:sim/prep/pack_ec_lipf6.py
# sim/prep/pack_ec_lipf6.py
"""
Build a packed EC:LiPF6 box at target composition and box size.

Usage:
  python sim/prep/pack_ec_lipf6.py --n-ec 512 --n-lipf6 64 --box 40.0 \
      --out sim/prep/packed/packed.data

Notes:
  - For Packmol, emit a temporary .inp if desired; otherwise write a crude lattice placement
    (OK since NPT→NVT will relax it). This is a scaffold; replace placement with Packmol calls if you prefer.
"""
from __future__ import annotations
import argparse, json, os, sys
import numpy as np

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--n-ec", type=int, required=True)
    ap.add_argument("--n-lipf6", type=int, required=True)
    ap.add_argument("--box", type=float, required=True, help="cubic box length in Å")
    ap.add_argument("--out", type=str, required=True)
    ap.add_argument("--summary", type=str, default="results/prep_logs/pack_summary.json")
    args = ap.parse_args()

    L = args.box
    os.makedirs(os.path.dirname(args.out), exist_ok=True)
    os.makedirs(os.path.dirname(args.summary), exist_ok=True)

    # Placeholder: random non-overlapping points (very rough); swap with Packmol for real projects.
    rng = np.random.default_rng(42)
    n_atoms = args.n_ec * 8 + args.n_lipf6 * 8  # rough atom count guess for EC and LiPF6
    coords = rng.random((n_atoms, 3)) * L

    # Minimal LAMMPS data header (skeleton; replace with real molecule templates)
    with open(args.out, "w") as f:
        f.write("LAMMPS data file (scaffold) -- replace with Packmol output\n\n")
        f.write(f"{n_atoms} atoms\n\n")
        f.write(f"0.0 {L:.6f} xlo xhi\n0.0 {L:.6f} ylo yhi\n0.0 {L:.6f} zlo zhi\n\n")
        f.write("Atoms\n\n")
        for i, (x,y,z) in enumerate(coords, start=1):
            f.write(f"{i} 1 1 {x:.6f} {y:.6f} {z:.6f}\n")  # id mol type x y z (stub)

    with open(args.summary, "w") as s:
        json.dump({
            "n_ec": args.n_ec,
            "n_lipf6": args.n_lipf6,
            "box_A": L,
            "atoms_stub": n_atoms,
            "note": "Replace scaffold coordinates with Packmol-based packing."
        }, s, indent=2)

if __name__ == "__main__":
    sys.exit(main())

```



```lammps title:sim/prep/equilibrate_npt_nvt.in
# sim/prep/equilibrate_npt_nvt.in
# One-time NPT -> NVT relaxation to produce common_start.* (Phase 1 will fill in details)
units           real
atom_style      full
boundary        p p p

# INPUTS
read_data       sim/prep/packed/packed.data

# Includes
include         sim/configs/run_constants.in
# TODO: pick one FF for prep only (non-reactive surrogate or A_QEq)
# include      sim/configs/A_QEq.in

# Pair style / charges (placeholder; set correctly in Phase 1)
# pair_style    reax/c NULL
# pair_coeff    * * sim/configs/params/reaxff_A.ff C H O Li F P

# NPT leg (placeholder time constants)
reset_timestep  0
fix             bar all press/berendsen iso 1.0 1.0 1000.0
fix             tstat all langevin ${T} ${T} 50.0 98765 zero yes
fix             int all nve
run             20000    # ~2 ps at 0.1 fs (adjust later)

unfix           bar
unfix           tstat
unfix           int

# NVT leg
fix             tstat all langevin ${T} ${T} 50.0 12345 zero yes
fix             int all nve
run             20000

# Write outputs
write_data      sim/prep/equil/equil.data
write_restart   sim/prep/equil/equil.restart

```


```Python title:analysis/io/load_trajectories.py
# analysis/io/load_trajectories.py
"""
Minimal placeholder to centralize trajectory reading later.
"""
from __future__ import annotations

def sanity():
    return True

```



```markdown title:"<!-- README.md -->"
<!-- README.md -->
# EC ReaxFF Robustness Study

This repo evaluates whether earliest EC decomposition mechanisms predicted by ReaxFF
are robust to (i) parameter-set choice and (ii) charge-equilibration scheme (QEq vs. ACKS2)
under matched mechanics.

## Quick start (Phase 0)

```bash
make dirs
make env
make seeds
```


- Fill `env/lammps_build_notes.md` with your actual build details.
- Replace the scaffold in `sim/prep/pack_ec_lipf6.py` with Packmol-based packing before Phase 1.
- Edit `sim/configs/run_constants.in` only in Phase 2 once timestep/neighbor/thermostat are validated.

Outputs live under `results/`, inputs/templates under `sim/`, analysis code under `analysis/`.


```yaml title:"CITATION.cff"
# CITATION.cff
cff-version: 1.2.0
message: "If you use this project, please cite it as below."
title: "Robustness of early EC decomposition in ReaxFF: parameter sets and QEq vs. ACKS2"
authors:
  - family-names: Your-Name
    given-names: First
version: "0.1.0"
date-released: "2025-09-21"
```




# Phase 1 Prepare the Common Starting Configuration


```
ec-reaxff-robustness/
├─ sim/
│  ├─ prep/
│  │  ├─ pack_ec_lipf6.py                 # script to build EC:LiPF6 mixture (counts, box)
│  │  ├─ packmol/
│  │  │  ├─ packmol.inp                   # optional: Packmol template for initial placement
│  │  │  └─ ec_lipf6.xyz                  # EC + LiPF6 monomer geometries
│  │  ├─ equilibrate_npt_nvt.in           # LAMMPS: NPT→NVT at target (T, ρ, x)
│  │  ├─ validate_nve.in                  # short NVE drift check (timestep/neighbor sanity)
│  │  ├─ freeze_positions.py              # strips velocities; writes common_start.{data,xyz}
│  │  ├─ statepoint.yaml                  # T, density, composition, box; provenance/notes
│  │  ├─ packed/
│  │  │  ├─ packed.data                   # raw packed configuration (pre-equilibration)
│  │  │  ├─ pack.log                      # packer stdout/log
│  │  │  └─ visuals/
│  │  │     └─ packed_snapshot.xyz        # quick visual sanity snapshot
│  │  ├─ equil/
│  │  │  ├─ equil.restart                 # engine-native restart at end of NVT
│  │  │  ├─ equil.data                    # same state in text (cell + coords; no vel)
│  │  │  ├─ equil.xyz                     # trajectory snippet for inspection
│  │  │  ├─ thermo.log                    # NPT→NVT thermodynamics (P, T, ρ vs time)
│  │  │  └─ rdf_probe.csv                 # quick Li–O / Li–F / C–O g(r) check (optional)
│  │  ├─ nve_check/
│  │  │  ├─ nve.log                       # energy drift report over ~50–100 ps
│  │  │  └─ drift_summary.txt             # |ΔE| per ps; pass/fail note
│  │  └─ common_start/
│  │     ├─ common_start.data             # immutable coordinates (text)
│  │     ├─ common_start.restart          # immutable engine-native restart
│  │     └─ common_start.xyz              # human-readable snapshot (no velocities)
│  └─ configs/
│     ├─ run_constants.in                 # already present from Phase 0 (timestep, neighbor, etc.)
│     └─ README.md                        # note: prep used <which FF>, but only coords are carried forward
├─ analysis/
│  └─ io/
│     └─ quick_check_prep.py              # tiny script to verify counts, box, neutrality, RDF minima
└─ results/
   └─ prep_logs/
      ├─ pack_summary.json                # molecule counts, box vectors, density
      ├─ equil_summary.json               # stabilized ρ, ⟨P⟩, ⟨E⟩, g(r) minima
      └─ nve_summary.json                 # drift metrics used to sign off timestep/neighbor

```



```yaml title:sim/prep/statepoint.yaml
# State point used for the one-time preparation
temperature_K: 330.0
target_density_g_cm3: 1.30              # for the EC:LiPF6 mixture at chosen x (example)
composition:
  EC: 512                                # molecules
  LiPF6: 64                              # formula units
box:
  type: cubic
  length_A: 40.0                         # initial guess; NPT will relax
notes: |
  This file defines ONLY the thermodynamic state and composition used to build the
  single shared structure. No model-specific settings belong here.
```


```.j2 title:sim/prep/packmol/packmol.inp.j2
# Packmol template (Jinja2). Units: Å. Box is [0,L] in each axis.
tolerance 2.0
filetype xyz
output {{ out_xyz }}

structure {{ ec_xyz }}
  number {{ n_ec }}
  inside box 0.0 0.0 0.0 {{ L }} {{ L }} {{ L }}
end structure

structure {{ lipf6_xyz }}
  number {{ n_lipf6 }}
  inside box 0.0 0.0 0.0 {{ L }} {{ L }} {{ L }}
end structure

```


```Python title:"sim/prep/pack_ec_lipf6.py"
#!/usr/bin/env python
from __future__ import annotations
import argparse, json, os, shutil, subprocess, sys, tempfile
import yaml
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]

def run(cmd, cwd=None):
    p = subprocess.run(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    if p.returncode != 0:
        print(p.stdout)
        raise SystemExit(f"Command failed: {' '.join(cmd)}")
    return p.stdout

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--state", default=str(ROOT/"sim/prep/statepoint.yaml"))
    ap.add_argument("--out-data", default=str(ROOT/"sim/prep/packed/packed.data"))
    ap.add_argument("--summary", default=str(ROOT/"results/prep_logs/pack_summary.json"))
    ap.add_argument("--packmol", default="packmol")
    args = ap.parse_args()

    with open(args.state) as f:
        sp = yaml.safe_load(f)

    n_ec = int(sp["composition"]["EC"])
    n_lipf6 = int(sp["composition"]["LiPF6"])
    L = float(sp["box"]["length_A"])

    out_xyz = ROOT/"sim/prep/packed/packed.xyz"
    out_data = Path(args.out_data)
    out_data.parent.mkdir(parents=True, exist_ok=True)
    Path(args.summary).parent.mkdir(parents=True, exist_ok=True)

    # Prefer Packmol if available; else write a crude random scaffold.
    if shutil.which(args.packmol):
        tpl = (ROOT/"sim/prep/packmol/packmol.inp.j2").read_text()
        inp = tpl.replace("{{ out_xyz }}", str(out_xyz)) \
                 .replace("{{ ec_xyz }}", str(ROOT/"sim/prep/packmol/ec.xyz")) \
                 .replace("{{ lipf6_xyz }}", str(ROOT/"sim/prep/packmol/lipf6.xyz")) \
                 .replace("{{ n_ec }}", str(n_ec)) \
                 .replace("{{ n_lipf6 }}", str(n_lipf6)) \
                 .replace("{{ L }}", f"{L}")
        with tempfile.TemporaryDirectory() as td:
            Path(td, "packmol.inp").write_text(inp)
            log = run([args.packmol, "<", "packmol.inp"], cwd=td)
            (ROOT/"sim/prep/packed/pack.log").write_text(log)
            shutil.move(str(Path(td)/out_xyz.name), out_xyz)
    else:
        # Fallback: minimal placeholder xyz (not chemistry-accurate)
        import numpy as np
        n_atoms_guess = (n_ec + n_lipf6)*8
        coords = np.random.default_rng(42).random((n_atoms_guess,3))*L
        with open(out_xyz, "w") as f:
            f.write(f"{n_atoms_guess}\nscaffold\n")
            for x,y,z in coords:
                f.write(f"C {x:.4f} {y:.4f} {z:.4f}\n")

    # Convert XYZ -> LAMMPS data (simple molecule-type-less scaffold via LAMMPS)
    lmp_in = f"""
units real
atom_style atomic
boundary p p p
region box block 0 {L} 0 {L} 0 {L} units box
create_box 1 box
read_data {out_xyz} fix xyz  # lammps will map elements; this is a placeholder route
write_data {out_data}
"""
    # Safer route is to use your own converter; here we call LAMMPS if available:
    if shutil.which("lmp"):
        tmp = Path(tempfile.mkdtemp())
        inp = tmp/"xyz2data.in"
        inp.write_text(lmp_in)
        run(["lmp", "-in", str(inp)])
        shutil.move(str(tmp/out_data.name), out_data)
    else:
        out_data.write_text("LAMMPS data file placeholder written by pack_ec_lipf6.py\n")

    (ROOT/"results/prep_logs/pack_summary.json").write_text(json.dumps({
        "n_ec": n_ec, "n_lipf6": n_lipf6, "box_length_A": L,
        "output_data": str(out_data),
        "note": "Replace placeholders with chemically faithful packing if Packmol not used."
    }, indent=2))

if __name__ == "__main__":
    sys.exit(main())

```



```ini title:"sim/prep/equilibrate_npt_nvt.in"
# One-time NPT -> NVT to generate an equilibrated liquid. Write both data & restart.
units           real
atom_style      full
boundary        p p p
atom_modify     map yes

# ---- Inputs
read_data       sim/prep/packed/packed.data

# Invariant mechanics (dt, neighbor, thermostat cadence placeholders from Phase 0/2)
include         sim/configs/run_constants.in

# ---- Choose ONE model for prep ONLY (do not change later). Prefer non-reactive if available.
# include      sim/configs/A_QEq.in           # acceptable if window is short/cool so no chemistry occurs

# ---- ReaxFF pair style (fill once model chosen)
# pair_style    reaxff lmp_control
# pair_coeff    * * sim/configs/params/reaxff_A.ff C H O Li F P

# ---- Thermo & dumps
thermo_style    custom step temp press pe etotal density vol
thermo          ${thermo_every}

# ---- NPT (relax density)
reset_timestep  0
fix bar all press/berendsen iso 1.0 1.0 1000.0
fix tstat all langevin ${T} ${T} 50.0 77777 zero yes
fix int all nve
run  500000    # ~50 ps if dt=0.1 fs (adjust to reach stable ρ)

unfix bar
unfix tstat
unfix int

# ---- NVT (stabilize local structure at fixed volume)
fix tstat all langevin ${T} ${T} 50.0 88888 zero yes
fix int all nve
run  500000    # ~50 ps

# ---- Outputs
write_data      sim/prep/equil/equil.data
write_restart   sim/prep/equil/equil.restart
```


```Python title:sim/prep/to_xyz.in
units real
atom_style full
boundary p p p
read_data  sim/prep/equil/equil.data
dump dx all xyz 1 sim/prep/equil/equil.xyz
run 0
```



```lammps title:"sim/prep/freeze_positions.py"
units real
atom_style full
boundary p p p
read_data  sim/prep/equil/equil.data
dump dx all xyz 1 sim/prep/equil/equil.xyz
run 0

```



```Python title:"sim/prep/freeze_positions.py"
#!/usr/bin/env python
"""
Strip velocities and thermostat state, write immutable common_start.{data,restart,xyz}.
"""
from __future__ import annotations
import argparse, os, json
from pathlib import Path

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--in-data", default="sim/prep/equil/equil.data")
    ap.add_argument("--in-restart", default="sim/prep/equil/equil.restart")
    ap.add_argument("--outdir", default="sim/prep/common_start")
    ap.add_argument("--summary", default="results/prep_logs/equil_summary.json")
    args = ap.parse_args()

    outdir = Path(args.outdir); outdir.mkdir(parents=True, exist_ok=True)

    # Use LAMMPS to zero velocities and re-write a clean data+restart
    # (Works even if original equilibration carried velocities/thermostat state)
    clean_in = f"""
units real
atom_style full
boundary p p p
read_data {args.in_data}
velocity all create 0.0 12345 mom yes rot yes dist gaussian
set atom * vx 0.0 vy 0.0 vz 0.0
write_data {outdir/'common_start.data'}
write_restart {outdir/'common_start.restart'}
dump dx all xyz 1 {outdir/'common_start.xyz'}
run 0
"""
    tmp = Path(".tmp_freeze.in")
    tmp.write_text(clean_in)
    os.system(f"lmp -in {tmp}")  # replace 'lmp' with your LAMMPS launcher if different
    tmp.unlink(missing_ok=True)

    Path(args.summary).parent.mkdir(parents=True, exist_ok=True)
    Path(args.summary).write_text(json.dumps({
        "source": {"data": args.in_data, "restart": args.in_restart},
        "outputs": {
            "data": str(outdir/'common_start.data'),
            "restart": str(outdir/'common_start.restart'),
            "xyz": str(outdir/'common_start.xyz'),
        },
        "note": "Coordinates frozen; velocities zeroed. Use velocities from seeds during production."
    }, indent=2))

if __name__ == "__main__":
    main()

```



```Python title:"sim/prep/equil/probe_rdf.py"
#!/usr/bin/env python
from __future__ import annotations
import argparse, numpy as np, MDAnalysis as mda, json
from MDAnalysis.analysis.rdf import InterRDF

ap = argparse.ArgumentParser()
ap.add_argument("--traj", default="sim/prep/equil/equil.xyz")
ap.add_argument("--top", default="sim/prep/equil/equil.data")
ap.add_argument("--out", default="results/prep_logs/equil_summary.json")
args = ap.parse_args()

u = mda.Universe(args.top, args.traj, format="LAMMPS")
# Placeholder selections—replace with your atom typing
sel_Li = u.select_atoms("name Li")
sel_O  = u.select_atoms("name O")
rdf = InterRDF(sel_Li, sel_O, range=(0.0, 6.0), nbins=300)
rdf.run()
rc_min = rdf.bins[np.argmin(rdf.rdf[(rdf.bins>1.5) & (rdf.bins<3.5)])]
with open(args.out, "w") as f:
    json.dump({"rdf_LiO_first_min_A": float(rc_min)}, f, indent=2)

```


## Quick runbook (Phase 1)

```bash
# 1) Pack once (fills sim/prep/packed/packed.data and results/prep_logs/pack_summary.json)
python sim/prep/pack_ec_lipf6.py

# 2) Equilibrate once (produces sim/prep/equil/equil.{data,restart})
lmp -in sim/prep/equilibrate_npt_nvt.in

# 3) Freeze coordinates (writes sim/prep/common_start/common_start.{data,restart,xyz})
python sim/prep/freeze_positions.py

```



# Phase 2 Validate Integrator/Neighbor Settings


## NVE Drift + Neighbor Probes (LAMMPS)

```
ec-reaxff-robustness/
├─ sim/
│  ├─ configs/
│  │  ├─ run_constants.in              # UPDATED: chosen timestep, neighbor skin, neighbor freq, thermostat style/params
│  │  ├─ neighbor_scan.yaml            # optional: tried {dt, skin, neigh_every} and notes
│  │  └─ thermostat_params.md          # rationale for chosen thermostat & τ values; parity notes
│  ├─ validation/
│  │  ├─ nve_sanity.in                 # LAMMPS: 50–100 ps NVE on common_start; prints Etot every step
│  │  ├─ nve_sanity_small_dt.in        # optional: Δt/1.25 spot-run for comparison
│  │  ├─ neighbor_probe.in             # short NVE to test neighbor skin/build frequency combos
│  │  ├─ analyze_nve_drift.py          # parses logs → |ΔE|/atom/ps, linear fit slope, pass/fail
│  │  ├─ analyze_neighbor_events.py    # reports neighbor rebuild stats, missed pairs warnings
│  │  └─ manifests/
│  │     └─ validation_manifest.json   # records exact inputs, LAMMPS build, MPI/OMP layout
│  └─ prep/
│     └─ common_start/
│        ├─ common_start.data          # input coordinates for validation runs
│        └─ common_start.restart
├─ analysis/
│  ├─ viz/
│  │  ├─ plot_nve_drift.py             # produces Etot(t) and residuals; saves PNG/PDF
│  │  └─ styles.mplstyle
│  └─ io/
│     └─ read_lammps_log.py            # tiny helper to read thermo/log files
└─ results/
   └─ validation_logs/
      ├─ nve/
      │  ├─ nve_sanity.log             # raw LAMMPS thermo output (Etot, Temp)
      │  ├─ nve_sanity_small_dt.log    # optional comparison run
      │  ├─ drift_metrics.json         # computed slope, |ΔE|/atom/ps, window used
      │  └─ Etot_vs_time.png           # quick visual check
      └─ neighbor/
         ├─ neighbor_probe.log         # neighbor rebuild frequency, warnings
         └─ neighbor_summary.json      # chosen skin and neigh_every with justifications

```



```ini title:sim/validation/nve_sanity.in
# sim/validation/nve_sanity.in
units           real
atom_style      full
boundary        p p p
atom_modify     map yes
read_data       sim/prep/common_start/common_start.data

# Pull invariants (dt, neighbor skin/every) from run_constants.in
include         sim/configs/run_constants.in

# Pure NVE (no thermostat) to test energy drift at chosen dt/neighbor policy
unfix           tstat    # ensure no thermostat lingering from constants file
fix             int all nve

thermo_style    custom step temp pe ke etotal press
thermo          ${thermo_every}

# Write a lightweight log for the analyzer
variable        etot equal etotal
fix             f1 all print ${thermo_every} "${step} ${temp} ${etot}" file results/validation_logs/nve/nve_sanity.log screen no

run             500000    # ~50 ps if dt = 0.1 fs (adjust target window)

unfix           f1
unfix           int
```


```ini title:"sim/validation/neighbor_probe.in"
# sim/validation/neighbor_probe.in
# Short runs to test skin / rebuild frequency combos for missed-pair warnings & drift
units real
atom_style full
boundary p p p
read_data sim/prep/common_start/common_start.data

# Candidate grid (override constants here)
variable neigh_skin equal 2.0   # Å (edit)
variable neigh_every equal 1    # (edit)
timestep 0.10e-15               # s (edit)

neighbor ${neigh_skin} bin
neigh_modify every ${neigh_every} delay 0 check yes

fix int all nve
thermo_style custom step temp ke pe etotal press
thermo 1000
log results/validation_logs/neighbor/neighbor_probe.log
run 100000    # ~10 ps
unfix int
```


## Parser and Quick Stats (Python)


```Python title:"analyze_nve_drift.py"
# sim/validation/analyze_nve_drift.py
from __future__ import annotations
import argparse, json, numpy as np, pandas as pd
from pathlib import Path

def load_log(p):
    df = pd.read_csv(p, sep=r"\s+", names=["step","T","Etot"], engine="python")
    return df

def slope_per_ps(df, dt_fs: float):
    t_ps = df["step"] * (dt_fs*1e-3)  # fs → ps
    # robust linear fit Etot(t)
    A = np.vstack([t_ps, np.ones_like(t_ps)]).T
    m, b = np.linalg.lstsq(A, df["Etot"].values, rcond=None)[0]
    return float(m)  # energy units per ps (LAMMPS 'real' → kcal/mol per ps)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--log", default="results/validation_logs/nve/nve_sanity.log")
    ap.add_argument("--dt-fs", type=float, required=True, help="timestep in femtoseconds")
    ap.add_argument("--natoms", type=int, required=True)
    ap.add_argument("--out", default="results/validation_logs/nve/drift_metrics.json")
    args = ap.parse_args()

    Path(Path(args.out).parent).mkdir(parents=True, exist_ok=True)
    df = load_log(args.log)
    m = slope_per_ps(df, args.dt_fs)  # kcal/mol per ps
    per_atom_eV_ps = (m/args.natoms) * 0.0433641153087705  # kcal/mol → eV
    summ = {
        "dt_fs": args.dt_fs,
        "natoms": args.natoms,
        "slope_kcal_per_mol_ps": m,
        "drift_abs_eV_per_atom_ps": abs(per_atom_eV_ps),
        "criterion_eV_per_atom_ps": 1.0e-4,
        "pass": abs(per_atom_eV_ps) < 1.0e-4
    }
    Path(args.out).write_text(json.dumps(summ, indent=2))
    print(json.dumps(summ, indent=2))

if __name__ == "__main__":
    main()

```




```Python title:"sim/validation/analyze_neighbor_events.py"
# sim/validation/analyze_neighbor_events.py
from __future__ import annotations
import argparse, json, re
from pathlib import Path

WARN_PAT = re.compile(r"(Dangerous builds|WARNING: Neighbor list overflow|neighbor list rebuild)")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--log", default="results/validation_logs/neighbor/neighbor_probe.log")
    ap.add_argument("--out", default="results/validation_logs/neighbor/neighbor_summary.json")
    args = ap.parse_args()
    txt = Path(args.log).read_text() if Path(args.log).exists() else ""
    issues = WARN_PAT.findall(txt)
    summary = {
        "log": args.log,
        "issues_found": len(issues) > 0,
        "matches": issues[:20]
    }
    Path(Path(args.out).parent).mkdir(parents=True, exist_ok=True)
    Path(args.out).write_text(json.dumps(summary, indent=2))
    print(json.dumps(summary, indent=2))

if __name__ == "__main__":
    main()

```



## Locking the Thermostat Choice (Notes + Constants)

```markdown
<!-- sim/configs/thermostat_params.md -->
# Thermostat choice (finalized in Phase 2)

Chosen style: **Langevin** (zero-drift setting)
- Target T: ${T} K (from run_constants.in)
- Damping τ: 50–100 fs (chosen: TODO)
- Seed policy: use replica seed for reproducibility (see prod templates)
- zero yes: keep zero net momentum

Alternative considered: **Nosé–Hoover**
- Chain length: 3
- Tdamp: 100 fs
- Rejected because: TODO (e.g., slower equilibration, sensitivity at sub-fs dt)

Parity requirements:
- Same thermostat and parameters across **all** variants/replicas.
- NVE used only for drift sanity checks and short settle tests.

```



```ini title:"sim/configs/run_constants.in"
# sim/configs/run_constants.in  (update the placeholders once validated)
# -- invariant mechanics (FINAL after Phase 2) --
variable T                 equal 330.0
variable dt                equal 0.10e-15          # FINAL
variable neigh_skin        equal 2.0               # FINAL
variable neigh_every       equal 1                 # FINAL
variable thermo_every      equal 1000
variable dump_coord_stride equal 1000              # coords ~100–200 fs later
variable dump_bo_stride    equal 100               # BO/charges every 10–20 fs later

neighbor ${neigh_skin} bin
neigh_modify every ${neigh_every} delay 0 check yes
timestep ${dt}

# Thermostat (FINAL)
unfix tstat
fix tstat all langevin ${T} ${T} 75.0 12345 zero yes
fix_modify tstat temp thermo_temp

thermo ${thermo_every}
thermo_style custom step temp pe ke etotal press

```



## Runbook (Phase 2)


```bash
# 0) Make sure common_start exists (Phase 1)
ls sim/prep/common_start/common_start.data

# 1) Run NVE drift at candidate dt/neighbor settings
lmp -in sim/validation/nve_sanity.in

# 2) Analyze drift (fill natoms and dt)
python sim/validation/analyze_nve_drift.py --dt-fs 0.10 --natoms <N_ATOMS> \
  --log results/validation_logs/nve/nve_sanity.log \
  --out results/validation_logs/nve/drift_metrics.json

# 3) Spot-check smaller dt
lmp -in sim/validation/nve_sanity_small_dt.in
python sim/validation/analyze_nve_drift.py --dt-fs 0.08 --natoms <N_ATOMS> \
  --log results/validation_logs/nve/nve_sanity_small_dt.log \
  --out results/validation_logs/nve/drift_metrics_small_dt.json

# 4) Probe neighbor settings (edit skin/every inside the .in file as needed)
lmp -in sim/validation/neighbor_probe.in
python sim/validation/analyze_neighbor_events.py

# 5) If drift < 1e-4 eV/atom/ps and no neighbor issues, UPDATE:
#    sim/configs/run_constants.in  (dt, neigh_skin, neigh_every, thermostat)
#    sim/configs/thermostat_params.md (brief rationale)

```





# Phase 3 Define the Four Model Variants


```
ec-reaxff-robustness/
├─ sim/
│  ├─ configs/
│  │  ├─ run_constants.in                 # invariant mechanics (from Phase 2; unchanged here)
│  │  ├─ params/
│  │  │  ├─ reaxff_A.ff                   # parameter set A
│  │  │  └─ reaxff_B.ff                   # parameter set B
│  │  ├─ A_QEq.in                         # includes: reaxff_A.ff, fix qeq style, tol, maxiter
│  │  ├─ A_ACKS2.in                       # includes: reaxff_A.ff, fix acks2 style, tol, maxiter
│  │  ├─ B_QEq.in                         # includes: reaxff_B.ff, fix qeq style, tol, maxiter
│  │  ├─ B_ACKS2.in                       # includes: reaxff_B.ff, fix acks2 style, tol, maxiter
│  │  ├─ charge_solver_parity.yaml        # matched tolerances (rtol, atol), maxiter, constraint settings
│  │  └─ README.md                        # notes: only lever = {params, charge style}; everything else via run_constants.in
│  ├─ validation/
│  │  ├─ charge_parity_probe.in           # tiny run: prints per-step residuals for QEq/ACKS2 on common_start
│  │  ├─ analyze_charge_residuals.py      # parses logs → residual stats, iter counts, parity check
│  │  └─ manifests/
│  │     └─ charge_parity_manifest.json   # records exact solver settings used in probe
│  └─ prep/
│     └─ common_start/
│        ├─ common_start.data
│        └─ common_start.restart
├─ analysis/
│  └─ io/
│     └─ parse_charge_logs.py             # helper to read residual/iteration logs from engines
└─ results/
   └─ parity_logs/
      ├─ A_QEq/
      │  └─ charge_probe.log              # residuals vs step; iteration counts
      ├─ A_ACKS2/
      │  └─ charge_probe.log
      ├─ B_QEq/
      │  └─ charge_probe.log
      ├─ B_ACKS2/
      │  └─ charge_probe.log
      └─ parity_summary.json              # confirms matched accuracy across schemes/sets

```


```yaml title:"sim/configs/charge_solver_parity.yaml"
# Matched accuracy across schemes (edit once, used everywhere)
rtol: 1.0e-8          # relative tolerance target for the linear solve
atol: 1.0e-10         # absolute floor (useful when charges ~ 0)
maxiter: 200          # identical cap so neither scheme is handicapped
# Optional extras if your engine exposes them:
preconditioner: jacobi
constraint: net_charge_zero
log_every: 100        # print a residual sample every N MD steps during probes

```


## Variant Includes (Only Pick Param File + Charge Scheme)


```ini title:sim/configs/A_QEq.in
# Variant: A + QEq
variable reaxff_param string "sim/configs/params/reaxff_A.ff"
variable charge_scheme string "QEq"            # consumed by engine-specific include
# tolerances pulled from charge_solver_parity.yaml by your launcher or templater

```


```ini title:sim/configs/A_ACKS2.in
# Variant: A + ACKS2
variable reaxff_param string "sim/configs/params/reaxff_A.ff"
variable charge_scheme string "ACKS2"

```



```ini title:sim/configs/B_QEq.in
# Variant: B + QEq
variable reaxff_param string "sim/configs/params/reaxff_B.ff"
variable charge_scheme string "QEq"

```


```ini title:sim/configs/B_ACKS2.in
# Variant: B + ACKS2
variable reaxff_param string "sim/configs/params/reaxff_B.ff"
variable charge_scheme string "ACKS2"

```



## Engine Glue (Drop our exact `fix` lines here once; Variants will just `include` them)


```lmp title:"sim/configs/charges/QEq.inc.lmp"
# Expect variables defined upstream:
# - reaxff_param (path)
# - qeq_rtol, qeq_atol, qeq_maxiter (numbers)
# Define the pair style + QEq fix for your build of LAMMPS.
# >>> EDIT these two lines to match your installation <<<
pair_style  reaxff  lmp_control
pair_coeff  * * ${reaxff_param} C H O Li F P

# Example (placeholder): replace with your engine’s QEq invocation
# fix ch all qeq/reax 1 0.0 10.0 ${qeq_rtol} ${qeq_maxiter}
# NOTE: If your build uses reax/c, the command name/args differ. Keep all parity knobs wired to variables.

```



```lmp title:"sim/configs/charges/ACKS2.inc.lmp"
# Same expectations as QEq.inc.lmp, but for ACKS2
pair_style  reaxff  lmp_control
pair_coeff  * * ${reaxff_param} C H O Li F P

# Example (placeholder): replace with your engine’s ACKS2 invocation
# fix ch all acks2/reaxff ${qeq_rtol} ${qeq_maxiter}
# Keep tolerance + maxiter variable-driven so parity is guaranteed.

```

**How to pass tolerances into those includes:** in your the generator from Phase 4 read `charge_solver_parity.yaml` and emit variables `qeq_rtol`, `qeq_atol`, and `qeq_maxiter` into each concrete input (or write a tiny prelude file that sets them before including `QEq.inc.lmp` / `ACKS2.inc.lmp`).


## Quick Probe to Confirm Parity at Runtime


```ini title:"sim/validation/charge_parity_probe.in"
# Short NVT on common_start that periodically prints charge-solver residuals/iters.
units       real
atom_style  full
boundary    p p p
read_data   sim/prep/common_start/common_start.data
include     sim/configs/run_constants.in

# ---- inject tolerances generated from charge_solver_parity.yaml (via templater)
variable qeq_rtol    equal 1.0e-8
variable qeq_atol    equal 1.0e-10
variable qeq_maxiter equal 200
variable scheme      string "${charge_scheme}"  # set by including one of A_QEq.in, etc.

# ---- choose scheme by including the right glue
# (your launcher will `include` exactly one of A_QEq.in, A_ACKS2.in, B_QEq.in, B_ACKS2.in before this file)
if "${scheme} == QEq" then "include sim/configs/charges/QEq.inc.lmp"
if "${scheme} == ACKS2" then "include sim/configs/charges/ACKS2.inc.lmp"

# ---- light thermostat to keep T stable while we sample residuals
unfix tstat
fix tstat all langevin ${T} ${T} 75.0 24680 zero yes
fix int   all nve

# ---- optional: your engine may expose residual/iteration counters; arrange a print every N steps
# If not, keep this as a placeholder; the analyzer can still parse counts if your build logs them.
variable step equal step
# Example placeholders (replace with real computes/variables if available):
# variable res  equal f_ch_residual
# variable it   equal f_ch_iterations

# Print step + (optional) residual + iter to a variant-specific log
fix f1 all print ${thermo_every} "${step}" file results/parity_logs/__VARIANT__/charge_probe.log screen no

run 20000    # a few ps are enough to collect samples

unfix f1
unfix int
unfix tstat

```


Replace `__VARIANT__` at submit time (your launcher already knows the variant) so logs land in `results/parity_logs/A_QEq/charge_probe.log`, etc.


## Parser for Probe


```Python title:"sim/validation/analyze_charge_residuals.py"
from __future__ import annotations
import argparse, json
from pathlib import Path

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--logs", nargs="+", required=True)  # e.g., results/parity_logs/*/charge_probe.log
    ap.add_argument("--out", default="results/parity_logs/parity_summary.json")
    args = ap.parse_args()

    # Skeleton: if your build prints residuals/iters, parse them here.
    # For now, just check that files exist and have similar line counts.
    sizes = {}
    for log in args.logs:
        p = Path(log)
        sizes[p.parent.name] = {"exists": p.exists(), "lines": sum(1 for _ in p.open()) if p.exists() else 0}

    Path(args.out).parent.mkdir(parents=True, exist_ok=True)
    Path(args.out).write_text(json.dumps({"charge_probe": sizes}, indent=2))
    print(json.dumps({"charge_probe": sizes}, indent=2))

if __name__ == "__main__":
    main()
```


**_How you’ll wire this at launch (no code changes later):_** In your per-replica input generator (Phase 4), do three things when you render each concrete `.in`:

1.) Include **exactly one** of `A_QEq.in`, `A_ACKS2.in`, `B_QEq.in`, `B_ACKS2.in`.
2.) Read `charge_solver_parity.yaml` and emit:


```
variable qeq_rtol    equal <rtol>
variable qeq_atol    equal <atol>
variable qeq_maxiter equal <maxiter>
```

3.) Include the corresponding engine glue once:

```nginx
if "${charge_scheme} == QEq"   then "include sim/configs/charges/QEq.inc.lmp"
if "${charge_scheme} == ACKS2" then "include sim/configs/charges/ACKS2.inc.lmp"
```





# Phase 4 Replica Generators


```
ec-reaxff-robustness/
├─ sim/
│  ├─ seedlist.txt                          # 1..N seeds; same index used across variants
│  ├─ configs/
│  │  ├─ run_constants.in                   # invariant mechanics (dt, neighbor, thermostat, I/O cadence)
│  │  ├─ A_QEq.in
│  │  ├─ A_ACKS2.in
│  │  ├─ B_QEq.in
│  │  └─ B_ACKS2.in
│  ├─ prep/
│  │  └─ common_start/
│  │     ├─ common_start.data               # immutable coordinates
│  │     └─ common_start.restart
│  └─ prod/
│     ├─ templates/
│     │  ├─ settle_then_prod.in             # LAMMPS script: brief settle → production; includes variant file
│     │  ├─ input_vars.template             # per-replica vars (seed, paths, traj lengths) for jinja/format
│     │  └─ log_custom.compute              # defines thermo/bond-order/charge outputs
│     ├─ generators/
│     │  ├─ make_replica_inputs.py          # reads seedlist → writes per-replica input/vars for each variant
│     │  ├─ assign_velocities.py            # MB draw at T using replica seed; writes velocity file (optional)
│     │  └─ manifest_writer.py              # emits per-replica manifest.json (env, versions, seeds)
│     ├─ slurm/
│     │  ├─ launch_array_A_QEq.sh           # sbatch --array=1-N maps TASK_ID→REPLICA_ID
│     │  ├─ launch_array_A_ACKS2.sh
│     │  ├─ launch_array_B_QEq.sh
│     │  ├─ launch_array_B_ACKS2.sh
│     │  └─ slurm_common.sh                 # shared SBATCH resources, module loads, MPI/OMP layout
│     ├─ A_QEq/
│     │  ├─ inputs/                         # auto-generated *.in / vars for each replica
│     │  │  └─ r{0001..NNNN}/
│     │  │     ├─ in.settle_then_prod       # concrete LAMMPS input (includes run_constants + A_QEq.in)
│     │  │     ├─ vars.in                   # numeric vars for this replica (seed, steps, write cadences)
│     │  │     └─ manifest.json             # replica metadata (seed, variant, git/LAMMPS info)
│     │  └─ r{0001..NNNN}/                  # outputs land here per replica (created at runtime)
│     ├─ A_ACKS2/
│     │  ├─ inputs/
│     │  │  └─ r{0001..NNNN}/ (as above)
│     │  └─ r{0001..NNNN}/
│     ├─ B_QEq/
│     │  ├─ inputs/
│     │  │  └─ r{0001..NNNN}/ (as above)
│     │  └─ r{0001..NNNN}/
│     └─ B_ACKS2/
│        ├─ inputs/
│        │  └─ r{0001..NNNN}/ (as above)
│        └─ r{0001..NNNN}/
├─ results/
│  └─ prod_logs/
│     ├─ A_QEq/
│     │  └─ r{0001..NNNN}/
│     │     ├─ log.lammps                   # thermo (includes charge-solve residual snapshots)
│     │     ├─ traj.xyz                     # coords @ 100–200 fs cadence
│     │     ├─ bondorder.csv                # selected BO time series @ 10–20 fs
│     │     ├─ charges.csv                  # partial charges for Li, PF6, carbonate sites
│     │     └─ run_manifest.json            # frozen copy of manifest + runtime hashes
│     ├─ A_ACKS2/
│     │  └─ r{0001..NNNN}/ (same layout)
│     ├─ B_QEq/
│     │  └─ r{0001..NNNN}/ (same layout)
│     └─ B_ACKS2/
│        └─ r{0001..NNNN}/ (same layout)
└─ analysis/
   └─ io/
      └─ harvest_prod.py                    # walks prod_logs/*/r*/ → parquet/CSV for detection pipeline

```


```yaml title:"sim/prod/run_control.yaml"
# Single source of truth for replica count and window/cadence
n_replicas: 48                 # default target per variant
window_ps: 150.0               # production length
dump:
  coord_stride: 1000           # frames ~ every 100–200 fs once dt is final
  bo_stride: 100               # bond-order & charges every 10–20 fs
settle_ps: 3.0                 # brief settle under variant’s charges/thermostat
variants:
  - A_QEq
  - A_ACKS2
  - B_QEq
  - B_ACKS2

```


```text title:"sim/prod/templates/settle_then_prod.in.j2"
# Autogenerated per-replica; includes invariant mechanics and variant lever.

units           real
atom_style      full
boundary        p p p
atom_modify     map yes

# --- I/O paths (rendered) ---
variable OUTDIR string "{{ outdir }}"
variable LOGDIR string "{{ logdir }}"
variable BO_STRIDE equal {{ bo_stride }}
variable COORD_STRIDE equal {{ coord_stride }}
variable STEPS_SETTLE equal {{ steps_settle }}
variable STEPS_PROD   equal {{ steps_prod }}

# --- common constants & start structure ---
include         sim/configs/run_constants.in
read_data       sim/prep/common_start/common_start.data

# --- set RNG seeds deterministically from replica id ---
variable REPL equal {{ replica_id }}
variable SEED equal {{ seed }}       # used by thermostat or velocity assignment

# --- variant switch: include tiny lever file (params + charge scheme name) ---
include         sim/configs/{{ variant }}.in

# --- inject matched tolerances from parity yaml (rendered by Python) ---
variable qeq_rtol    equal {{ qeq_rtol }}
variable qeq_atol    equal {{ qeq_atol }}
variable qeq_maxiter equal {{ qeq_maxiter }}

# --- include engine glue for the selected scheme ---
if "${charge_scheme} == QEq"   then "include sim/configs/charges/QEq.inc.lmp"
if "${charge_scheme} == ACKS2" then "include sim/configs/charges/ACKS2.inc.lmp"

# --- velocities: create MB field at T using the replica seed (CRN pairing) ---
velocity all create ${T} ${SEED} mom yes rot yes dist gaussian

# --- settle window to relax charges/polarization onto this variant’s manifold ---
fix tstat all langevin ${T} ${T} 75.0 ${SEED} zero yes
fix int   all nve
include   sim/prod/templates/log_custom.compute
run ${STEPS_SETTLE}

# --- production: same mechanics, logging on; identical window across variants ---
reset_timestep 0
# (keep thermostat for short reactive window per your design)
# or switch to NVT variant as desired; mechanics must match across variants.
run ${STEPS_PROD}

# --- outputs live under results/prod_logs/<variant>/rXXXX/ ---

```


```text title:"sim/prod/templates/log_custom.compute"
# Minimal logs required by analysis (Phase 5/6)
thermo_style custom step temp pe ke etotal press
thermo ${BO_STRIDE}

# Bond-order/charge logging (engine-specific; placeholders below)
# You’ll choose the exact atom IDs/groups at generation or write selective dumps
# Example coordinate dump:
dump dxyz all xyz ${COORD_STRIDE} ${OUTDIR}/traj.xyz
dump_modify dxyz element C H O Li F P

# Example lightweight thermo print (step, T, Etot) as a side log
fix fth all print ${BO_STRIDE} "${step} ${temp} ${etotal}" file ${LOGDIR}/log.lammps screen no

```


```text title:"sim/prod/templates/input_vars.template"
# Filled per replica (for debugging or provenance)
variant={{ variant }}
replica_id={{ replica_id }}
seed={{ seed }}
steps_settle={{ steps_settle }}
steps_prod={{ steps_prod }}
bo_stride={{ bo_stride }}
coord_stride={{ coord_stride }}
qeq_rtol={{ qeq_rtol }}
qeq_atol={{ qeq_atol }}
qeq_maxiter={{ qeq_maxiter }}
```



```Python title:"sim/prod/generators/make_replica_inputs.py"
#!/usr/bin/env python
from __future__ import annotations
import argparse, math, os, yaml, json
from pathlib import Path
from jinja2 import Template

ROOT = Path(__file__).resolve().parents[3]

def read_parity():
    p = ROOT/"sim/configs/charge_solver_parity.yaml"
    y = yaml.safe_load(p.read_text())
    return float(y["rtol"]), float(y.get("atol", 0.0)), int(y["maxiter"])

def steps(ps: float, dt_fs: float) -> int:
    return int(round(ps*1e3/dt_fs))

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--variant", required=True, choices=["A_QEq","A_ACKS2","B_QEq","B_ACKS2"])
    ap.add_argument("--dt-fs", required=True, type=float)
    ap.add_argument("--statefile", default=str(ROOT/"sim/prod/run_control.yaml"))
    ap.add_argument("--seedlist", default=str(ROOT/"sim/seedlist.txt"))
    args = ap.parse_args()

    cfg = yaml.safe_load(Path(args.statefile).read_text())
    nrep = int(cfg["n_replicas"])
    window_ps = float(cfg["window_ps"])
    settle_ps = float(cfg["settle_ps"])
    bo_stride = int(cfg["dump"]["bo_stride"])
    coord_stride = int(cfg["dump"]["coord_stride"])
    rtol, atol, maxiter = read_parity()

    tmpl = Template((ROOT/"sim/prod/templates/settle_then_prod.in.j2").read_text())
    var_dir = ROOT/f"sim/prod/{args.variant}"
    inputs_dir = var_dir/"inputs"
    inputs_dir.mkdir(parents=True, exist_ok=True)

    seeds = [int(s) for s in Path(args.seedlist).read_text().split()]
    assert len(seeds) >= nrep, "seedlist too short"

    for i in range(1, nrep+1):
        rid = f"r{i:04d}"
        seed = seeds[i-1]
        outdir = ROOT/f"results/prod_logs/{args.variant}/{rid}"
        logdir = outdir
        outdir.mkdir(parents=True, exist_ok=True)

        concrete = tmpl.render(
            outdir=outdir.as_posix(),
            logdir=logdir.as_posix(),
            bo_stride=bo_stride,
            coord_stride=coord_stride,
            steps_settle=steps(settle_ps, args.dt_fs),
            steps_prod=steps(window_ps, args.dt_fs),
            variant=args.variant,
            replica_id=i,
            seed=seed,
            qeq_rtol=rtol, qeq_atol=atol, qeq_maxiter=maxiter
        )
        (inputs_dir/rid).mkdir(parents=True, exist_ok=True)
        (inputs_dir/rid/"in.settle_then_prod").write_text(concrete)
        (inputs_dir/rid/"vars.txt").write_text(
            (ROOT/"sim/prod/templates/input_vars.template").read_text()
            .replace("{{ variant }}", args.variant)
            .replace("{{ replica_id }}", str(i))
            .replace("{{ seed }}", str(seed))
            .replace("{{ steps_settle }}", str(steps(settle_ps, args.dt_fs)))
            .replace("{{ steps_prod }}", str(steps(window_ps, args.dt_fs)))
            .replace("{{ bo_stride }}", str(bo_stride))
            .replace("{{ coord_stride }}", str(coord_stride))
            .replace("{{ qeq_rtol }}", f"{rtol}")
            .replace("{{ qeq_atol }}", f"{atol}")
            .replace("{{ qeq_maxiter }}", f"{maxiter}")
        )

if __name__ == "__main__":
    main()

```



```Python title:"sim/prod/generators/assign_velocities.py"
#!/usr/bin/env python
"""
Optional helper if you prefer to precompute velocity files per replica.
Otherwise, velocity creation happens inside LAMMPS using the same seed.
"""
from __future__ import annotations
import argparse
from pathlib import Path

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--variant", required=True)
    ap.add_argument("--replica", type=int, required=True)
    args = ap.parse_args()
    rid = f"r{args.replica:04d}"
    out = Path(f"sim/prod/{args.variant}/inputs/{rid}/velocities.lmp")
    out.parent.mkdir(parents=True, exist_ok=True)
    out.write_text("# placeholder: velocities are created in LAMMPS via 'velocity create'\n")
    print(out)

if __name__ == "__main__":
    main()

```



```Python title:"sim/prod/generators/manifest_writer.py"
#!/usr/bin/env python
from __future__ import annotations
import json, subprocess, os
from pathlib import Path

def git_rev() -> str:
    try:
        return subprocess.check_output(["git","rev-parse","HEAD"], text=True).strip()
    except Exception:
        return "UNKNOWN"

def write_manifest(variant: str, rid: str, seed: int, dest: Path):
    dest.write_text(json.dumps({
        "variant": variant,
        "replica_id": rid,
        "seed": seed,
        "git_commit": git_rev(),
        "env": {"lammps": os.environ.get("LAMMPS_EXE", "lmp")}
    }, indent=2))

```



```bash title:sim/prod/slurm/slurm_common.sh
#!/usr/bin/env bash
# Common SBATCH header flags (edit to your cluster)
#SBATCH -p compute
#SBATCH -N 1
#SBATCH -n 8
#SBATCH -t 04:00:00
#SBATCH --mem=8G
module purge
module load lammps  # or source your build
export LAMMPS_EXE=${LAMMPS_EXE:-lmp}

```




<span style="color:#ff0000; font-weight:bold">Note: For the following script, don't for get to clone and change the variant name for the other 3!</span>

```bash title:"sim/prod/slurm/launch_array_A_QEq.sh"
#!/usr/bin/env bash
set -euo pipefail
source "$(dirname "$0")/slurm_common.sh"

VARIANT=A_QEq
DT_FS=0.10            # must match sim/configs/run_constants.in (Phase 2)

# Generate inputs once per array submission
python sim/prod/generators/make_replica_inputs.py --variant ${VARIANT} --dt-fs ${DT_FS}

# Array over replicas
# SBATCH suggestion: set this in your sbatch call: --array=1-48
RID=$(printf "r%04d" "${SLURM_ARRAY_TASK_ID}")
INP="sim/prod/${VARIANT}/inputs/${RID}/in.settle_then_prod"
OUTDIR="results/prod_logs/${VARIANT}/${RID}"

mkdir -p "${OUTDIR}"
srun ${LAMMPS_EXE} -in "${INP}"

```




## Runbook

```bash
# 1) Generate inputs for one variant (reads run_control.yaml & seedlist.txt)
python sim/prod/generators/make_replica_inputs.py --variant A_QEq --dt-fs 0.10

# 2) Launch as an array (example for 48 replicas)
sbatch --array=1-48 sim/prod/slurm/launch_array_A_QEq.sh

# 3) Repeat for A_ACKS2, B_QEq, B_ACKS2 (or run in parallel queues)

```




# Phase 5 Production Runs


```
ec-reaxff-robustness/
├─ sim/
│  ├─ prod/
│  │  ├─ run_control.yaml                 # N_replicas per variant, window_ps, write cadences; single source of truth
│  │  ├─ templates/
│  │  │  ├─ settle_then_prod.in           # already present (Phase 4)
│  │  │  └─ log_custom.compute            # already present (Phase 4)
│  │  ├─ generators/
│  │  │  ├─ make_replica_inputs.py        # already present (Phase 4)
│  │  │  └─ manifest_writer.py            # already present (Phase 4)
│  │  ├─ slurm/
│  │  │  ├─ launch_array_A_QEq.sh         # --array=1-<N> reads run_control.yaml
│  │  │  ├─ launch_array_A_ACKS2.sh
│  │  │  ├─ launch_array_B_QEq.sh
│  │  │  ├─ launch_array_B_ACKS2.sh
│  │  │  └─ slurm_common.sh               # fixed resources; MPI/OMP layout pinned
│  │  ├─ A_QEq/
│  │  │  ├─ inputs/ r0001..rNNNN/         # per-replica concrete inputs (generated)
│  │  │  └─ r0001..rNNNN/                 # per-replica output dirs (created at runtime)
│  │  ├─ A_ACKS2/
│  │  │  ├─ inputs/ r0001..rNNNN/
│  │  │  └─ r0001..rNNNN/
│  │  ├─ B_QEq/
│  │  │  ├─ inputs/ r0001..rNNNN/
│  │  │  └─ r0001..rNNNN/
│  │  └─ B_ACKS2/
│  │     ├─ inputs/ r0001..rNNNN/
│  │     └─ r0001..rNNNN/
│  └─ configs/
│     └─ run_constants.in                 # invariant mechanics (dt, neighbor, thermostat, I/O cadence)
├─ results/
│  └─ prod_logs/
│     ├─ schema.md                        # documents file formats written per replica
│     ├─ A_QEq/
│     │  └─ r0001..rNNNN/
│     │     ├─ log.lammps                 # thermo with minimal fields; charge-solve residual snapshots
│     │     ├─ traj.xyz                   # coordinates every 100–200 fs
│     │     ├─ bondorder.csv              # selected BO pairs at 10–20 fs
│     │     ├─ charges.csv                # Li, PF6 (P,Fx), carbonate (C=O,O) partial charges
│     │     ├─ timing.json                # start/end times, window_ps, write cadences actually used
│     │     ├─ qc_pass.txt                # created by QC script if basic checks pass
│     │     └─ run_manifest.json          # seed, variant, git/LAMMPS build, MPI/OMP layout
│     ├─ A_ACKS2/
│     │  └─ r0001..rNNNN/ (same contents as above)
│     ├─ B_QEq/
│     │  └─ r0001..rNNNN/ (same contents as above)
│     └─ B_ACKS2/
│        └─ r0001..rNNNN/ (same contents as above)
├─ analysis/
│  └─ io/
│     ├─ harvest_prod.py                  # walks prod_logs → consolidated parquet/CSV
│     └─ qc/
│        ├─ verify_write_cadence.py       # checks cadence, missing frames, window length
│        └─ summarize_run_health.py       # extracts drift, thermostat stability, residual stats
└─ docs/
   └─ production_checklist.md             # runbook: arrays launch, expected counts, QC criteria

```


## Update the Per-Replica Logging Include


```text title:"sim/prod/templates/log_custom.compute"
# --- Thermo: minimal, steady cadence ---
thermo_style custom step temp etotal press
thermo ${BO_STRIDE}
fix fth all print ${BO_STRIDE} "${step} ${temp} ${etotal}" file ${LOGDIR}/log.lammps screen no

# --- Coordinates (for RDF/coordination) ---
dump dxyz all xyz ${COORD_STRIDE} ${OUTDIR}/traj.xyz
dump_modify dxyz element C H O Li F P

# --- Selected bond orders (engine-specific) ------------------------------
# For ReaxFF in LAMMPS, you can emit a per-pair BO via computes or per-atom masks.
# Leave placeholders here; wire your actual compute lines during bring-up.
# Required columns for analysis/bondorder.csv:
#   time_fs, BO_C_ringO, BO_OH, BO_PF, [optional extras]
# We print a CSV-like line at BO_STRIDE cadence.

variable time_fs equal step*dt*1.0e15

# Placeholders; replace with real expressions or fix print of reax bond order outputs
variable BO_C_ringO equal 0.0
variable BO_OH      equal 0.0
variable BO_PF      equal 0.0

fix fbo all print ${BO_STRIDE} \
"${time_fs} ${BO_C_ringO} ${BO_OH} ${BO_PF}" \
file ${OUTDIR}/bondorder.csv screen no

# --- Partial charges (subset only) ---------------------------------------
# Required columns for analysis/charges.csv:
#   time_fs, q_Li(sum or list), q_P, q_F1..q_F6, q_CO(carbonyl C), q_O1,q_O2
# If your build exposes per-atom charges (e.g., dump custom q), use a group & reduce.
# As a lightweight default, print variant-level sums/means you need for diagnostics.

variable qLi equal 0.0
variable qP  equal 0.0
variable qF1 equal 0.0
variable qF2 equal 0.0
variable qF3 equal 0.0
variable qF4 equal 0.0
variable qF5 equal 0.0
variable qF6 equal 0.0
variable qCO equal 0.0
variable qO1 equal 0.0
variable qO2 equal 0.0

fix fq all print ${BO_STRIDE} \
"${time_fs},${qLi},${qP},${qF1},${qF2},${qF3},${qF4},${qF5},${qF6},${qCO},${qO1},${qO2}" \
file ${OUTDIR}/charges.csv screen no

# --- Replica timing/audit file (JSON) ------------------------------------
# Write once at start with the planned window & cadences (your generator can also emit this)
# Here we append a final line at end via variable expansion into a JSON-like text.
variable window_ps   equal ${STEPS_PROD}*dt*1.0e12
variable bo_stridefs equal ${BO_STRIDE}*dt*1.0e15
variable xy_stridefs equal ${COORD_STRIDE}*dt*1.0e15
fix ftj all print ${BO_STRIDE} "{}" file ${OUTDIR}/timing.json screen no

```


Notes: the “placeholders” for BO/charges keep the scaffold light. When you wire your actual reaxff BO/charge outputs (e.g., via `compute reaxff/bonds`, `dump custom q`, or postprocessing), keep the **column names and cadences** as shown so downstream scripts work without edits.



## Define the Expected On-Disk Schema


```markdown title:"results/prod_logs/schema.md"
# Replica file schema (Phase 5)

**Every** `results/prod_logs/<variant>/<rXXXX>/` must contain:

- `log.lammps` — whitespace table with `step temp etotal` every `BO_STRIDE` steps.
- `traj.xyz` — XYZ at `COORD_STRIDE` cadence, with element labels {C,H,O,Li,F,P}.
- `bondorder.csv` — space- or comma-separated with header:

```


time_fs,BO_C_ringO,BO_OH,BO_PF

```csv title:"charges.csv"
- `charges.csv` — comma-separated with header:
```


time_fs,qLi,qP,qF1,qF2,qF3,qF4,qF5,qF6,qCO,qO1,qO2


```javascript title:"timing.json"
- `timing.json` — JSON with:
```







# Phase 6 Event Detection


```
ec-reaxff-robustness/
├─ analysis/
│  ├─ detectors/
│  │  ├─ event_rules.yaml                # BO thresholds, hysteresis (on/off), min_frames, tie-break order
│  │  ├─ bondorder_binarize.py           # two-threshold hysteresis; per-pair state machine
│  │  ├─ first_event_detector.py         # forward scan; applies library rules; emits event time/type or censor
│  │  ├─ connectivity_graph.py           # builds graph from binarized BO; connected components per frame
│  │  ├─ typing.py                       # product typing in post-event window (CO vs CO2, oligomers, Li–F present)
│  │  ├─ post_event_freeze.py            # extracts 2–5 ps window after trigger; writes snapshots & graphs
│  │  ├─ io_schema.md                    # defines required columns for bondorder.csv, charges.csv, traj.xyz
│  │  └─ tests/
│  │     ├─ test_hysteresis.py
│  │     ├─ test_rules.py
│  │     └─ fixtures/                    # tiny synthetic traces for unit tests
│  ├─ pipelines/
│  │  ├─ run_detection_variant.py        # CLI: one variant → read prod_logs → events.parquet + QC
│  │  ├─ run_detection_all.py            # orchestrates all four variants; parallel over replicas
│  │  └─ config.yaml                     # paths to prod_logs, output dirs, post-event window length
│  ├─ viz/
│  │  ├─ plot_event_timeline.py          # per-replica traces with trigger marker (for spot checks)
│  │  └─ plot_binarization_demo.py       # shows raw BO vs. hysteresis states around transitions
│  └─ io/
│     ├─ harvest_prod.py                 # (from Phase 5) loader for bondorder/charges/coords
│     └─ write_graphml.py                # saves connectivity graphs for inspection (optional)
├─ results/
│  ├─ event_detection/
│  │  ├─ A_QEq/
│  │  │  ├─ events.parquet               # one row/replica: {replica_id, event_type, t_event, censored}
│  │  │  ├─ post_event/
│  │  │  │  └─ r{0001..}/
│  │  │  │     ├─ freeze.xyz             # 2–5 ps snippet after trigger
│  │  │  │     ├─ graph.gml              # connectivity graph at end of freeze window
│  │  │  │     └─ typing.json            # product classification summary
│  │  │  └─ qc_report.json               # counts, missing-data checks, threshold version used
│  │  ├─ A_ACKS2/
│  │  │  └─ (same layout)
│  │  ├─ B_QEq/
│  │  │  └─ (same layout)
│  │  └─ B_ACKS2/
│  │     └─ (same layout)
│  └─ logs/
│     └─ detection_manifest.json         # hashes of event_rules.yaml, code versions, run timestamp
├─ sim/
│  └─ prod/
│     └─ templates/
│        └─ log_custom.compute           # (Phase 4) ensures needed BO/charge outputs exist
└─ docs/
   └─ detection_readme.md                # brief “how it works”, endpoints, and caveats

```


# Phase 7 Structural Context


```
ec-reaxff-robustness/
├─ analysis/
│  ├─ structure/
│  │  ├─ pre_event_slice.py                # selects frames < t_event per replica; length-bias-safe weighting
│  │  ├─ rdf_coord.py                      # computes g_{LiO}, g_{LiF}, g_{CO} and running coordinations
│  │  ├─ contact_cutoff.py                 # finds first-minimum r_c from Li–F g(r); variant or pooled option
│  │  ├─ lif_contact.py                    # builds Li–F contact traces with intermittency tolerance
│  │  ├─ lifetimes_km.py                   # KM survival of contact episodes; censored-aware medians/RMST
│  │  ├─ stratify_by_event.py              # splits replicas by eventual first-event type when counts allow
│  │  ├─ config.yaml                       # bins (Δr), r_max, weighting (per-replica), τ_gap, r_c policy
│  │  └─ __init__.py
│  ├─ pipelines/
│  │  ├─ run_structure_variant.py          # CLI: one variant → RDFs, coordinations, Li–F metrics
│  │  ├─ run_structure_all.py              # orchestrates all four variants; parallel over replicas
│  │  └─ paths.yaml                        # input: results/prod_logs/*; output: results/structure/*
│  ├─ viz/
│  │  ├─ plot_rdf_overlays.py              # overlays g(r) per variant; annotates first peak/minimum
│  │  ├─ plot_coordination.py              # running coordination and value at first minimum
│  │  ├─ plot_lif_contact_hist.py          # histogram (and optional log-x) of Li–F contact lifetimes
│  │  └─ plot_lif_km.py                    # KM curve for contact episodes with CIs and # at risk
│  └─ io/
│     ├─ harvest_prod.py                   # (Phase 5) loader reused here
│     └─ write_tables.py                   # saves tidy CSV/Parquet summaries (per-replica, per-variant)
├─ results/
│  ├─ structure/
│  │  ├─ A_QEq/
│  │  │  ├─ rdf/
│  │  │  │  ├─ g_LiO.csv                   # r, g(r) (per-replica avg, variant avg, bootstrap CIs)
│  │  │  │  ├─ g_LiF.csv
│  │  │  │  └─ g_CO.csv
│  │  │  ├─ coordination/
│  │  │  │  ├─ n_LiO.csv                   # running n(r); value at first minimum in header/metadata
│  │  │  │  ├─ n_LiF.csv
│  │  │  │  └─ n_CO.csv
│  │  │  ├─ lif_contact/
│  │  │  │  ├─ rc_metadata.json            # r_c from Li–F g(r); method (pooled/variant), Δr
│  │  │  │  ├─ freq_by_replica.csv         # time-fraction in contact per replica
│  │  │  │  ├─ lifetimes.csv               # episode durations with censor flags
│  │  │  │  └─ km_contact.json             # KM estimates + CIs, RMST to τ
│  │  │  └─ stratified/
│  │  │     ├─ ring_opening/…              # same subfolders for replicas that eventually ring-open
│  │  │     ├─ deprotonation/…
│  │  │     └─ pf6_dissociation/…
│  │  ├─ A_ACKS2/                          # same layout as A_QEq
│  │  ├─ B_QEq/                            # same layout
│  │  └─ B_ACKS2/                          # same layout
│  └─ figures/
│     ├─ rdf_overlays.png                  # Li–O, Li–F, C–O overlays with shared legend
│     ├─ coordination_at_min.png           # bar/inset of n at first minima across variants
│     ├─ lif_contact_hist.png              # Li–F contact lifetime histograms
│     └─ lif_contact_km.png                # KM survival of Li–F contact episodes
└─ docs/
   └─ structure_methods.md                 # brief notes on pre-event pooling, bootstraps, and cutoff policy

```



# Phase 8 Survival and Branching Statistics


```
ec-reaxff-robustness/
├─ analysis/
│  ├─ survival/
│  │  ├─ build_km.py                     # KM estimator (Greenwood SEs), percentiles, RMST(τ)
│  │  ├─ logrank_tests.py                # standard & stratified/weighted logrank
│  │  ├─ branching_stats.py              # counts → multinomial CIs; Fisher/χ² tests
│  │  ├─ effect_sizes.py                 # pairwise median-time ratios + bootstrap CIs; RMST diffs
│  │  ├─ paired_sensitivity.py           # optional: paired Δt (CRN pairs) + HL estimator
│  │  ├─ bootstrap_utils.py              # replica-level (and stratified) resampling helpers
│  │  ├─ loaders.py                      # reads results/event_detection/*/events.parquet
│  │  ├─ config.yaml                     # τ (window), primary endpoint, strata (e.g., temperature), n_boot
│  │  └─ tests/
│  │     ├─ test_km_small.py
│  │     ├─ test_branching.py
│  │     └─ fixtures/
│  ├─ pipelines/
│  │  ├─ run_survival_variant.py         # CLI: one variant → km.json, medians.csv, rmst.csv
│  │  └─ run_survival_all.py             # orchestrates four variants; computes pairwise effects & tests
│  ├─ viz/
│  │  ├─ plot_km_curves.py               # KM with CIs, numbers-at-risk; saves per-variant & overlay PNG/PDF
│  │  ├─ plot_branching_bars.py          # bars with multinomial CIs; includes “none within window”
│  │  └─ plot_effect_forest.py           # forest plot of median-time ratios (or RMST diffs) with CIs
│  └─ io/
│     └─ write_tables.py                 # tidy CSV/Parquet writers for summaries
├─ results/
│  ├─ event_detection/
│  │  └─ …                               # (from Phase 6) input events.parquet live here
│  └─ survival/
│     ├─ A_QEq/
│     │  ├─ km.json                      # t, S(t), pointwise SEs/CIs, # at risk
│     │  ├─ medians.csv                  # median/percentiles with CIs (or NA if censored)
│     │  ├─ rmst.csv                     # RMST(τ) with CI
│     │  └─ branching.csv                # counts & proportions with CIs
│     ├─ A_ACKS2/
│     │  └─ (same files as A_QEq)
│     ├─ B_QEq/
│     │  └─ (same files as A_QEq)
│     ├─ B_ACKS2/
│     │  └─ (same files as A_QEq)
│     ├─ comparisons/
│     │  ├─ logrank_summary.json         # p-values (standard/stratified/weighted), test settings
│     │  ├─ effects_median_ratio.csv     # pairwise ratios + bootstrap CIs
│     │  ├─ effects_rmst_diff.csv        # RMST differences/ratios + CIs (fallback when medians censor)
│     │  └─ paired_delta_summary.csv     # optional: paired Δt stats (subset where both had events)
│     └─ figures/
│        ├─ km_overlays.png
│        ├─ branching_bars.png
│        └─ effect_forest.png
└─ docs/
   └─ survival_methods.md                # endpoints, censoring policy, primary/secondary analyses

```



# Phase 9 Minimal Robustness Checks


```
ec-reaxff-robustness/
├─ analysis/
│  ├─ robustness/
│  │  ├─ hysteresis_sensitivity.py          # reruns detector on ~10% replicas with ±0.05 BO threshold shifts
│  │  ├─ dt_spotcheck.py                    # compares baseline vs Δt/1.25 on selected replicas; event parity & timing deltas
│  │  ├─ seed_swap_probe.py                 # swaps seeds between two variants for a tiny subset; checks Δt_event distribution
│  │  ├─ sample_selection.yaml              # which replicas to test (by variant/ID); fixed random seed
│  │  ├─ thresholds_delta.yaml              # {C–O, O–H, P–F}: on/off thresholds and ± shifts
│  │  ├─ report_robustness.py               # aggregates results → tables/plots; compares against primary CIs
│  │  └─ README.md                          # brief runbook, expected outputs, pass/fail criteria
│  ├─ detectors/
│  │  └─ event_rules.yaml                   # (from Phase 6) source thresholds; this remains the “primary” spec
│  └─ pipelines/
│     └─ run_detection_variant.py           # reused by hysteresis_sensitivity to regenerate events
├─ sim/
│  ├─ validation/
│  │  └─ nve_sanity_small_dt.in             # (from Phase 2) base for smaller-Δt runs
│  └─ prod/
│     ├─ templates/
│     │  └─ settle_then_prod.in             # (from Phase 4/5) reused for Δt spot-check
│     ├─ slurm/
│     │  ├─ launch_dt_spotcheck.sh          # sbatch helper for small-Δt subset
│     │  └─ launch_seed_swap.sh             # sbatch helper for seed-swap subset
│     └─ seed_swaps/
│        ├─ mapping.csv                     # rows: variant_A,replica → variant_B,replica (swap plan)
│        └─ README.md
├─ results/
│  ├─ robustness/
│  │  ├─ hysteresis/
│  │  │  ├─ A_QEq/events_shifted.parquet    # 10% subset; shifted thresholds results
│  │  │  ├─ A_ACKS2/events_shifted.parquet
│  │  │  ├─ B_QEq/events_shifted.parquet
│  │  │  ├─ B_ACKS2/events_shifted.parquet
│  │  │  └─ summary.json                    # flips, time jitters, KM/branching deltas vs primary
│  │  ├─ dt_spotcheck/
│  │  │  ├─ pairs.csv                        # baseline vs Δt/1.25 event types & times per replica
│  │  │  └─ summary.json                    # parity rate, timing Δ distribution, NVE drift comparison
│  │  ├─ seed_swap/
│  │  │  ├─ pairs.csv                        # original vs swapped Δt_event per pair
│  │  │  └─ summary.json                    # distributional tests showing CRN invariance
│  │  └─ figures/
│  │     ├─ jitter_hist.png                 # histogram of |Δt_event| for hysteresis & Δt checks
│  │     ├─ parity_confusion.png            # event-type parity confusion matrix (baseline vs Δt/shifted)
│  │     └─ seed_swap_violin.png            # Δ differences before/after swap
│  └─ logs/
│     └─ robustness_manifest.json           # code/threshold hashes, seeds, run timestamps
└─ docs/
   └─ robustness_notes.md                   # what passed, what failed, any caveats to include in write-up

```


